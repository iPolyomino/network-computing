#!/usr/bin/env python3
#
# An extensible graph library for Python.
# Copyright (c) 2018, Hiroyuki Ohsaki.
# All rights reserved.
#
# $Id: graphtools.py,v 1.14 2018/10/15 14:09:26 ohsaki Exp ohsaki $
#

import math
import os
import random
import re
import tempfile
import time

from perl import warn, die

CREATE_SUBP = {
    'random': 'create_random_graph',
    'random_sparse': 'create_random_sparse_graph',
    'barabasi': 'create_barabasi_graph',
    'ba': 'create_barabasi_graph',
    'barandom': 'create_barabasi_random_graph',
    'general_ba': 'create_generalized_barabasi_graph',
    'ring': 'create_ring_graph',
    'tree': 'create_tree_graph',
    'btree': 'create_btree_graph',
    'latent': 'create_latent_graph',
    'treeba': 'create_treeba_graph',
    'lattice': 'create_lattice_graph',
    'voronoi': 'create_voronoi_graph',
}
CREATE_TYPES = sorted(CREATE_SUBP.keys())

IMPORT_SUBP = {
    'dot': 'import_dot',
    'dimacs': 'import_dimacs',
    'inet': 'import_inet',
    'brite': 'import_brite',
    'gw': 'import_gw',
    'nsnode': 'import_nsnode',
    'nsagent': 'import_nsagent',
    'metis': 'import_metis',
    'edge': 'import_edge',
    'cell': 'import_cell',
}
IMPORT_FORMATS = sorted(IMPORT_SUBP.keys())

EXPORT_SUBP = {
    'dot': 'export_dot',
    'dimacs': 'export_dimacs',
    'inet': 'export_inet',
    'nsnode': 'export_nsnode',
    'nsagent': 'export_nsagent',
    'nsagent_edge': 'export_nsagent_edge',
    'nsagent_udp': 'export_nsagent_udp',
    'metis': 'export_metis',
    'pdnsnode': 'export_pdnsnode',
    'pdnsagent': 'export_pdnsagent',
    'gdl': 'export_gdl',
    'cell': 'export_cell',
}
EXPORT_FORMATS = sorted(EXPORT_SUBP.keys())

MAX_RETRIES = 100

METIS_EDGE_WEIGHT_MASK = 1
METIS_VERTEX_WEIGHT_MASK = 2

PDNS_NETMASK = '255.255.255.0'
PDNS_AGENT_PORT = 1234

def str2number(v):
    # FIXME: shoud not check type
    if type(v) != str:
        return v
    # remove preceeding/trailing spaces
    v = v.strip()
    if v.startswith('0x'):
        return int(v, 16)
    elif re.match(r'[\d+-]+$', v):
        return int(v)
    elif re.match(r'[\d.eE+-]+$', v):
        return float(v)
    else:
        return v

class Graph:
    def __init__(self, directed=True, multiedged=True):
        self.G = {}
        self.V = {}
        self.EI = {}
        self.EO = {}
        self.T = {}
        self._directed = directed

    def __repr__(self):
        return self.export_dot()

    def directed(self):
        return self._directed

    def undirected(self):
        return not self._directed

    def multiedged(self):
        return True

    def set_graph_attribute(self, attr, val):
        self.G[attr] = val

    def get_graph_attribute(self, attr):
        return self.G.get(attr, None)

    def average_degree(self):
        total, count = 0, 0
        for v in self.vertices():
            total += self.degree(v)
            count += 1
        return total / count

    def expect_undirected(self):
        if not self.undirected():
            die('undirected graph expected')

    def expect_directed(self):
        if not self.directed():
            die('directed graph expected')

    def expect_multiedged(self):
        if not self.multiedged():
            die('multiedged graph expected')

    # vertex ----------------------------------------------------------------
    def vertices(self):
        return list(self.V.keys())

    def has_vertex(self, v):
        if self.V.get(v, None) is None:
            return False
        else:
            return True

    def add_vertex(self, v):
        if not self.has_vertex(v):
            self.V[v] = {}  # default vertex attribute

    def add_vertices(self, *vertices):
        for v in vertices:
            self.add_vertex(v)

    def predecessors(self, v, ignore=False):
        if not ignore:
            self.expect_directed()
        if not self.EI.get(v, None):
            return []
        return list(self.EI[v].keys())

    def successors(self, u, ignore=False):
        if not ignore:
            self.expect_directed()
        if not self.EO.get(u, None):
            return []
        return list(self.EO[u].keys())

    def neighbors(self, v):
        found = set()
        for u in self.predecessors(v, ignore=True):
            found.add(u)
        for u in self.successors(v, ignore=True):
            found.add(u)
        return list(found)

    def set_vertex_attribute(self, v, attr, val):
        if not self.has_vertex(v):
            self.add_vertex(v)
        self.V[v][attr] = val

    def get_vertex_attribute(self, v, attr):
        return self.V[v].get(attr, None)

    def set_vertex_attributes(self, v, adict):
        for key, val in adict.items():
            self.V[v][key] = val

    def get_vertex_attributes(self, v):
        return self.V.get(v, {})

    def set_vertex_weight(self, v, val):
        return self.set_vertex_attribute(v, 'weight', val)

    def get_vertex_weight(self, v):
        return self.get_vertex_attribute(v, 'weight')

    def delete_vertex(self, v):
        if not self.has_vertex(v):
            return None
        for u in self.neighbors(v):
            try:
                del self.EO[u][v]
            except KeyError:
                pass
            try:
                del self.EI[u][v]
            except KeyError:
                pass
        del self.V[v]
        try:
            del self.EO[v]
        except KeyError:
            pass
        try:
            del self.EI[v]
        except KeyError:
            pass

    def delete_vertices(self, alist):
        for v in alist:
            self.delete_vertex(v)

    def random_vertex(self):
        return random.choice(self.vertices())

    # edge ----------------------------------------------------------------
    def edges(self):
        found = []
        for u in self.EO:
            for v in self.EO[u]:
                for id in self.get_multiedge_ids(u, v):
                    found.append([u, v])
        return found

    def unique_edges(self):
        found = []
        for u in self.EO:
            for v in self.EO[u]:
                found.append([u, v])
        return found

    def has_edge(self, u, v):
        if self.undirected() and u > v:
            u, v = v, u
        if not self.EO.get(u, None):
            return False
        if not self.EO[u].get(v, None):
            return False
        return True

    # return the continue edge ID, which is equivalent to the number of
    # multi-edges between vertices
    def get_multiedge_ids(self, u, v):
        if self.undirected() and u > v:
            u, v = v, u
        if not self.has_edge(u, v):
            return []
        return list(self.EO[u][v].keys())

    def get_edge_count(self, u, v):
        ids = self.get_multiedge_ids(u, v)
        if ids:
            return len(ids)
        else:
            return 0

    def add_edge(self, u, v):
        if self.undirected() and u > v:
            u, v = v, u
        count = self.get_edge_count(u, v)
        self.add_vertices(u, v)
        if not self.EO.get(u, None):
            self.EO[u] = {}
        if not self.EO[u].get(v, None):
            self.EO[u][v] = {}
        self.EO[u][v][count] = {}  # default vertex attribute
        if not self.EI.get(v, None):
            self.EI[v] = {}
        if not self.EI[v].get(u, None):
            self.EI[v][u] = {}
        self.EI[v][u][count] = {}  # default vertex attribute
        return count

    def delete_edge(self, u, v):
        if self.undirected() and u > v:
            u, v = v, u
        if not self.has_edge(u, v):
            return None
        count = self.get_edge_count(u, v) - 1
        del self.EO[u][v][count]
        del self.EI[v][u][count]
        if (count == 0):
            del self.EO[u][v]
            del self.EI[v][u]
        return count

    def edges_from(self, u, ignore=False):
        if not ignore:
            self.expect_directed()
        found = []
        for v in self.successors(u, ignore):
            for count in self.get_multiedge_ids(u, v):
                found.append([u, v])
        return found

    def edges_to(self, v, ignore=False):
        if not ignore:
            self.expect_directed()
        found = []
        for u in self.predecessors(v, ignore):
            for count in self.EI[v][u]:
                found.append([u, v])
        return found

    def edges_at(self, v):
        found = []
        found.extend(self.edges_from(v, ignore=True))
        found.extend(self.edges_to(v, ignore=True))
        return found

    def out_degree(self, u, ignore=False):
        if not ignore:
            self.expect_directed()
        return len(self.edges_from(u))

    def in_degree(self, v, ignore=False):
        if not ignore:
            self.expect_directed()
        return len(self.edges_to(v))

    def degree(self, v):
        if self.undirected():
            return len(self.edges_at(v))
        else:
            return self.in_degree(v) + self.out_degree(v)

    vertex_degree = degree

    def random_edge(self):
        return random.choice(self.edges())

    def set_edge_attribute_by_id(self, u, v, id, attr, val):
        if not attr:
            warn('set_edge_attribute_by_id: no attribute specified.')

        if self.undirected() and u > v:
            u, v = v, u
        self.EO[u][v].setdefault(id, {})
        self.EO[u][v][id][attr] = val

    def get_edge_attribute_by_id(self, u, v, id, attr):
        if not attr:
            warn('get_edge_attribute_by_id: no attribute specified.')
        if self.undirected() and u > v:
            u, v = v, u
        return self.EO[u][v][id].get(attr, None)

    def set_edge_attributes_by_id(self, u, v, id, adict):
        if self.undirected() and u > v:
            u, v = v, u
        for key, val in adict.items():
            self.EO[u][v][id][key] = val

    def get_edge_attributes_by_id(self, u, v, id):
        if self.undirected() and u > v:
            u, v = v, u
        return self.EO[u][v][id]

    def set_edge_weight_by_id(self, u, v, id, val):
        return self.set_edge_attribute_by_id(u, v, id, 'weight', val)

    def get_edge_weight_by_id(self, u, v, id):
        return self.get_edge_attribute_by_id(u, v, id, 'weight')

    def set_edge_weight(self, u, v, w):
        return self.set_edge_attribute_by_id(u, v, 0, 'weight', w)

    def get_edge_weight(self, u, v):
        return self.get_edge_attribute_by_id(u, v, 0, 'weight')

    # algorithm ----------------------------------------------------------------
    def dijkstra(self, s):
        self.expect_directed()
        dist = {}
        prev = {}
        for v in self.vertices():
            prev[v] = v
        dist[s] = 0

        S = []
        Q = self.vertices()
        INFINITY = 2 << 30
        while Q:
            Q = sorted(Q, key=lambda x: dist.get(x, INFINITY))
            u = Q.pop(0)
            if dist.get(u, None) is None:
                break
            S.append(u)
            for v in self.successors(u):
                # FIXME: must reject multi-edged graph
                w = self.get_edge_weight_by_id(u, v, 0) or 1
                if dist.get(v, None) is None \
                    or dist[v] > (dist.get(u, INFINITY) + w):
                    dist[v] = dist[u] + w
                    prev[v] = u
        return dist, prev

    def dijkstra_all_pairs(self):
        for v in self.vertices():
            self.T[v] = self.dijkstra(v)

    def floyd_warshall(self):
        self.expect_directed()
        # initialize weight matrix
        # NOTE: works well for sparse graphs
        path = {}
        next = {}
        for v in self.vertices():
            path[v] = {}
            next[v] = {}

        for e in self.edges():
            path[e[0]][e[1]] = self.get_edge_weight_by_id(*e, 0) or 1

        # run Floyd-Warshall algorithm to find all-pairs shortest paths
        # NOTE: Floyd-Warshall is good for _ in DENSE graphs:
        INFINITY = 10**10
        for k in self.vertices():
            for u in self.vertices():
                for v in self.vertices():
                    if path[u].get(k, INFINITY) + path[k].get(v, INFINITY) \
                        < path[u].get(v, INFINITY):
                        path[u][v] = path[u][k] + path[k][v]
                        next[u][v] = k
        self.T = path

    def is_reachable(self, u, v):
        if not self.T.get(u, None):
            dist, prev = self.dijkstra(u)
            self.T[u] = dist
        return self.T[u].get(v, None)

    def is_connected(self):
        v = self.random_vertex()
        explored = self.explore(v)
        return len(explored) == len(self.vertices())

    def explore(self, s):
        explored = set()
        need_visit = set()
        need_visit.add(s)
        while need_visit:
            u = need_visit.pop()
            explored.add(u)
            for v in self.neighbors(u):
                if v not in explored:
                    need_visit.add(v)
        return explored

    # return all components (i.e., connected subgraphs)
    def components(self):
        components = []
        # record unvisisted vertices
        unvisited = set(self.vertices())
        while unvisited:
            # start exploration from one of unvisited vertices
            v = unvisited.pop()
            explored = self.explore(v)
            components.append(explored)
            # remove all visisted vertices
            unvisited -= explored
        # return components in descending order (?)
        return components

    def maximal_component(self):
        components = sorted(self.components(), key=lambda x: len(x))
        return components[-1]

    # graph ----------------------------------------------------------------
    def copy_graph(self):
        T = Graph(directed=self.directed(), multiedged=self.multiedged())
        for v in self.vertices():
            T.add_vertex(v)
            T.set_vertex_attributes(v, self.get_vertex_attributes(v))

        for e in self.edges():
            T.add_edge(*e)
            for id in self.get_multiedge_ids(*e):
                T.set_edge_attributes_by_id(*e, id, \
                    self.get_edge_attributes_by_id(*e, id))
        return T

    def directed_copy(self):
        T = Graph(directed=True, multiedged=self.multiedged())
        for v in self.vertices():
            T.add_vertex(v)

        for e in self.edges():
            T.add_edge(*e)
            if self.undirected():
                T.add_edge(e[1], e[0])

        return T

    def complete_graph(self):
        for u in self.vertices():
            for v in self.vertices():
                if u >= v:
                    continue
                if not self.has_edge(u, v):
                    self.add_edge(u, v)
        return self

    # util ----------------------------------------------------------------
    def header_string(self, comment='# '):
        date = time.strftime('%Y/%M/%D %H:%M:%S', time.localtime())
        type = 'directed' if self.is_directed() else 'undirected'
        vcount = len(self.vertices())
        ecount = len(self.edges())
        astr = f"""{comment}Generated by graphtools (version 1.0) at {date}
{comment}{type}, {vcount} vertices, {ecount} edges
"""
        return astr

    # create ----------------------------------------------------------------
    def create_graph(self, atype, *args):
        name = CREATE_SUBP.get(atype, None)
        if not name:
            warn(f"No graph creation support for type `{type}'")
            return None
        method = getattr(self, name, None)
        if not method:
            warn(f"Graph creation method `{name}' not found")
            return None
        return method(*args)

    def create_random_graph(self, N=10, E=20, no_multiedge=False):
        if E < N:
            die('Too small number of edges')

        for v in range(1, N + 1):
            self.add_vertices(v)

        # add first (N - 1) edges for making sure connectivity
        for i in range(1, N):
            u = i + 1
            v = random.randrange(1, u)
            if random.uniform(0, 1) >= 0.5:
                self.add_edge(u, v)
            else:
                self.add_edge(v, u)

        # randomly add remaining (E - (N - 1)) edges
        for i in range(1, E - (N - 1) + 1):
            # FIXME: avoid cycle edges, but this may take log time
            ntries = 1
            while ntries < MAX_RETRIES:
                u = random.randrange(1, N + 1)
                v = random.randrange(1, N + 1)
                if not no_multiedge and u != v:
                    break
                if no_multiedge and u != v and not self.has_edge(u, v):
                    break
            self.add_edge(u, v)
        return self

    def create_random_sparse_graph(self, N=10, E=20, no_multiedge=False):
        for i in range(1, N + 1):
            self.add_vertices(i)

        # randomly add remaining Eedges
        for i in range(1, E + 1):
            # FIXME: avoid cycle edges, but this may take log time
            ntries = 1
            while ntries < MAX_RETRIES:
                u = random.randrange(1, N + 1)
                v = random.randrange(1, N + 1)
                if not no_multiedge and u != v:
                    break
                if no_multiedge and u != v and not self.has_edge(u, v):
                    break
            self.add_edge(u, v)
        return self

    def create_barabasi_graph(self, N=10, m0=2, m=2):
        self.expect_undirected()

        for v in range(1, m0 + 1):
            self.add_vertex(v)
        self = self.complete_graph()

        # create complete graph with m0 vertices

        step = N - m0
        for _ in range(1, step + 1):
            # add a new vertex with m edges
            u = m0 + _
            self.add_vertex(u)

            # attach to a vertex using preferential attachment
            edges = self.edges()
            for i in range(1, m + 1):
                # NOTE: degree-preferential attachment is realized by
                # selecting a vertex connected to a randomly-chosen edge.
                edge = random.choice(edges)
                v = edge[random.randrange(0, 2)]
                self.add_edge(u, v)
        return self

    def create_barabasi_random_graph(self, N=10, E=20, m0=2):
        self.expect_undirected()

        # create complete graph with m0 vertices
        for v in range(1, m0 + 1):
            self.add_vertex(v)
        self = self.complete_graph()

        # calcurate number of edges to be connected per vertex
        E0 = m0 * (m0 - 1) / 2
        nedges = (E - E0) / (N - m0)

        # add remaining (N - m0) vertices
        for u in range(m0 + 1, N + 1):
            self.add_vertex(u)

            # attach to a vertex using preferential attachment
            # NOTE: degree-preferential attachment is realized by
            # selecting a vertex connected to a randomly-chosen edge.
            edges = self.edges()
            while True:
                edge = random.choice(edges)
                v = edge[random.randrange(0, 2)]
                self.add_edge(u, v)

                # NOTE: using the fact that the average number of
                # successes of infinite Bernoulli traials with probability
                # p is given by 1/p.
                if random.uniform(0, 1) <= 1 / nedges:
                    break
        return self

    def create_ring_graph(self, N=10, step=1):
        for v in range(1, N + 1):
            self.add_vertices(v)

        # add (N - 1) edges for making circular topology
        for _ in range(0, N):
            u = _ + 1
            v = ((_ + step) % N) + 1
            self.add_edge(u, v)

        return self

    def create_tree_graph(self, N=10):
        self.add_vertex(1)

        # add (N - 1) edges for _ in making tree topology:
        for v in range(2, N + 1):
            u = random.randrange(1, v)
            self.add_edge(u, v)

        return self

    # binary tree graph
    def create_btree_graph(self, N=10):
        depth = 0
        nedges = 1
        finished = False
        while not finished:
            vleft = 2**depth
            for count in range(1, 2**depth + 1):
                v = vleft + (count - 1)
                parent = int(v / 2)
                if (parent == 0):
                    continue
                self.add_edge(v, parent)
                self.set_vertex_attribute(v, 'latent', 1 / depth)
                nedges += 1
                if nedges >= N:
                    finished = True
                    break
            depth += 1
        return self

    # tree BA graph
    def create_treeba_graph(self, N=10, alpha=1):
        self.expect_directed()
        attract = []

        # create an initial vertex
        self.add_vertex(1)
        attract[1] = alpha + self.in_edges(1)

        # create a vertex and attach to another using preferential attachment
        for u in range(2, N + 1):

            # randomly choose a vertex with a probability proportional to attract
            total = 0
            for _ in attract:
                total += _ or 0
            frac = random.uniform(0, total)
            sum = 0
            for v in range(1, N):
                sum += attract[v]
                if frac < sum:
                    self.add_edge(u, v)
                    attract[u] = alpha + self.in_edges(u)
                    attract[v] = alpha + self.in_edges(v)
                    break
        return self

    # Generalized BA model proposed in S. N. Dorogovtsev, ``Structure of
    # growing networks with preferential linking,'' Phisical Review
    # Letters, vol. 85, no. 21, pp. 4633 -= 14636, Nov. 2000.
    def create_generalized_barabasi_graph(self, N=10, m0=2, m=2, gamma=3):
        self.expect_directed()
        A = m * (gamma - 2)

        # create complete graph with m0 vertices
        self.add_vertices([v for v in range(1, m0 + 1)])
        self = self.complete_graph()

        step = N - m0
        for _ in range(1, step + 1):
            # add a new vertex with m edges
            u = m0 + _
            self.add_vertex(u)

            # attach to a vertex using preferential attachment
            vcount = self.vertices() - 1
            ecount = self.edges()
            for _ in range(1, m + 1):
                # NOTE: preferential-attachement with probability A + in_degree
                total = A * vcount + ecount
                thresh = random.uniform(0, total)
                sum = 0
                for v in range(1, u):
                    sum += A + self.in_degree(v)
                    if sum >= thresh:
                        # make sure newly added node has at least single link
                        if _ == 1:
                            self.add_edge(u, v)
                        else:
                            self.add_edge(random.randrange(1, u + 1), v)
                        break

        return self

    def create_latent_graph(self,
                            N=10,
                            E=20,
                            error_ratio=0,
                            confer='linear',
                            dist='normal',
                            alpha=10):
        # assign latent variables
        alist = []
        if dist == 'uniform':
            alist = [random.uniform(0, 1) for _ in range(N)]
        if dist == 'normal':
            alist = [random.normalvariate(1 / 2, 1 / 6) for _ in range(N)]
        if dist == 'exponential':
            alist = [random.expovariate(1 / 3) for _ in range(N)]

        alist = sorted(alist)
        for _ in range(1, N + 1):
            self.set_vertex_attribute(_, 'latent', alist[_ - 1])

        nedges = 0
        while nedges < E * (1 - error_ratio):
            u = random.randrange(1, N + 1)
            v = random.randrange(1, N + 1)
            if u == v:
                continue
            lu = self.get_vertex_attribute(u, 'latent')
            lv = self.get_vertex_attribute(v, 'latent')
            prob = 1.0
            if confer == 'abs':
                prob = lv
            elif confer == 'binary':
                if lv <= lu:
                    prob = 0
            elif confer == 'linear':
                if lv > lu:
                    prob = lv - lu
                else:
                    prob = 0
            elif confer == 'sigmoid':
                prob = 1 / (1 + math.exp(-alpha * (lv - lu)))

            if not random.uniform(0, 1) <= prob:
                continue
            self.add_edge(u, v)
            nedges += 1

        ## add disturbance
        while nedges < E:
            u = random.randrange(1, N + 1)
            v = random.randrange(1, N + 1)
            if u == v:
                continue
            self.add_edge(u, v)
            nedges += 1

        return self

    def _lattice_vertex(self, dim, n, *positions):
        v = 0
        for i in positions:
            v *= n
            if i > n:
                i -= n
            if i < 1:
                i += n
            v += i - 1
        return v + 1

    def create_lattice_graph(self, dim=2, n=5, is_torus=False):
        if dim == 1:
            for i in range(1, n + 1):
                u = self._lattice_vertex(dim, n, i)
                v = self._lattice_vertex(dim, n, i + 1)
                if is_torus or v > u:
                    self.add_edge(u, v)

        elif dim == 2:
            for j in range(1, n + 1):
                for i in range(1, n + 1):
                    u = self._lattice_vertex(dim, n, i, j)
                    v = self._lattice_vertex(dim, n, i + 1, j)
                    if is_torus or v > u:
                        self.add_edge(u, v)
                    v = self._lattice_vertex(dim, n, i, j + 1)
                    if is_torus or v > u:
                        self.add_edge(u, v)

        return self

    def create_voronoi_graph(self, npoints=10, width=1, height=1):
        tmpfile = tempfile.mkstemp()[1]
        with os.popen(f'voronoi >{tmpfile}', 'w') as pipe:
            for v in range(npoints):
                x, y = random.uniform(0, width), random.uniform(0, height)
                pipe.write(f'{x} {y}\n')
        with open(tmpfile) as f:
            n = 1
            for line in f:
                m = re.match('v\s+(\S+)\s+(\S+)', line)
                if m:
                    x, y = m.groups()
                    # FIXME: quick hack to pack within WIDTH x HEIGHT field
                    x = max(min(float(x), width), 0)
                    y = max(min(float(y), height), 0)
                    self.add_vertex(n)
                    self.set_vertex_attribute(n, 'pos', f"{x},{y}")
                    n += 1
                m = re.match('e\s+(\S+)\s+(\S+)\s+(\S+)', line)
                if m:
                    e, u, v = m.groups()
                    u, v = int(u) + 1, int(v) + 1
                    if u > 0 and v > 0:
                        self.add_edge(u, v)
        os.unlink(tmpfile)
        return self

    # import ----------------------------------------------------------------
    def import_graph(self, fmt, *args):
        name = IMPORT_SUBP.get(fmt, None)
        method = getattr(self, name, None)
        if not name or not method:
            die(f"No import support for graph format `{fmt}'")
        return method(*args)

    def import_dot(self, lines):
        buf = ''
        for line in lines:
            # remove C++-style comment
            pos = line.find('//')
            if pos >= 0:
                line = line[pos:]
            line = line.strip()
            buf += line
        # remove C-style comment
        buf = re.sub(r'/\*.*?\*/', '', buf)
        m = re.search(r'graph\s+(\S+)\s*{(.*)}', buf)
        if not m:
            die('Invalid graph format (missing dot graph header)')
        body = m.group(2)
        return self._import_dot_body(body)

    def _import_dot_body(self, body_str):
        for line in body_str.split(';'):
            line = line.strip()
            if not line:
                continue
            if 'graph' in line or 'node' in line or 'edge' in line:
                continue
            m = re.match(r'([^\[]*)\s*(\[(.*)\])?', line)
            if not m:
                continue

            val, opts = m.group(1), m.group(3) or ''
            val = val.replace('\"', '')

            # parse attributes [name1=val1,name2=val2...]
            attrs = {}
            for pair in opts.split(','):
                if not pair:
                    break
                akey, aval = pair.split('=', 2)
                attrs[akey] = aval.replace('\"', '')

            # parse vertex/edge definition
            # FIXME: this might be problematic...
            if '--' in val or '->' in val:  # vertex -- vertex [-- vertex...]
                vertices = re.split(r'\s*-[->]\s*', val)
                while len(vertices) >= 2:
                    u, v = vertices[0], vertices[1]
                    u, v = str2number(u), str2number(v)
                    i = self.add_edge_get_id(u, v)
                    self.set_edge_attributes_by_id(u, v, i, attrs)
                    vertices.pop(0)
            else:  # vertex
                v = str2number(val)
                self.add_vertex(v)
                self.set_vertex_attributes(v, attrs)

    def import_dot_quick(self, listp):
        raise NotImplementedError

    def import_dimacs(self, listp):
        raise NotImplementedError

    def import_inet(self, listp):
        raise NotImplementedError

    def import_brite(self, listp):
        raise NotImplementedError

    def import_gw(self, listp):
        raise NotImplementedError

    def import_nsnode(self, listp):
        raise NotImplementedError

    def import_nsagent(self, listp):
        raise NotImplementedError

    def import_metis(self, listp):
        raise NotImplementedError

    def import_edge(self, listp):
        raise NotImplementedError

    def import_cell(self, listp):
        raise NotImplementedError

    # ----------------------------------------------------------------

    def export_graph(self, fmt, *args):
        name = EXPORT_SUBP.get(fmt, None)
        method = getattr(self, name, None)
        if not name or not method:
            die(f"No export support for graph format `{fmt}'")
        return method(*args)

    def export_dot(self, *args):
        astr = self.header_string('// ')
        head = 'digraph' if self.is_directed() else 'graph'
        astr += head + ' export_dot {\n  node [color=gray90,style=filled];\n'
        for v in sorted(self.vertices()):
            astr += f'  "{v}"'
            attrs = self.get_vertex_attributes(v)
            if attrs:
                alist = []
                for key, val in attrs.items():
                    alist.append(f'{key}="{val}"')
                astr += ' [' + (', '.join(alist)) + ']'
            astr += ';\n'

        for edge in sorted(self.unique_edges(), key=lambda e: e[0]):
            u = edge[0]
            v = edge[1]
            l = '->' if self.is_directed() else '--'
            for i in self.get_multiedge_ids(u, v):
                astr += f'  "{u}" {l} "{v}"'
                attrs = self.get_edge_attributes_by_id(u, v, i)
                if attrs:
                    alist = []
                    for key, val in attrs.items():
                        alist.append(f'{key}="{val}"')
                    astr += ' [' + (', '.join(alist)) + ']'
                astr += ';\n'
        astr += '}\n'
        return astr

    def export_dimacs(self):
        raise NotImplementedError

    def export_inet(self):
        raise NotImplementedError

    def export_brite(self):
        raise NotImplementedError

    def export_gw(self):
        raise NotImplementedError

    def export_nsnode(self):
        raise NotImplementedError

    def export_nsagent(self):
        raise NotImplementedError

    def export_nsagent_edge(self, N):
        raise NotImplementedError

    def export_nsagent_udp(self):
        raise NotImplementedError

    def export_metis(self):
        raise NotImplementedError

    def is_included(v, partp, n):
        raise NotImplementedError

    # return IP address of link U-V at side W in N-th partition
    # FIXME: assuming number of nodes < 256
    def get_link_ipaddr(u, v, w, n):
        raise NotImplementedError

    # return IP address of remote link U-V at side W
    # FIXME: assuming number of nodes < 256
    def get_rlink_ipaddr(u, v, w):
        raise NotImplementedError

    def export_pdnsnode(self, partp, n):
        raise NotImplementedError

    def export_pdnsagent(T, partp, n, self):
        raise NotImplementedError

    def export_gdl(self):
        raise NotImplementedError

    def export_cell(self):
        raise NotImplementedError

    is_directed = directed
    is_undirected = undirected
    is_multiedged = multiedged
    add_edge_get_id = add_edge
    out_edges = edges_from
    in_edges = edges_to

def main():
    g = Graph()
    g.create_voronoi_graph()
    s = g.export_dot()
    print(s)
    raise

if __name__ == "__main__":
    main()
