head	1.2;
access;
symbols;
locks
	ohsaki:1.2; strict;
comment	@# @;


1.2
date	2018.10.15.12.48.51;	author ohsaki;	state Exp;
branches;
next	1.1;

1.1
date	2018.05.27.09.02.15;	author ohsaki;	state Exp;
branches;
next	;


desc
@@


1.2
log
@*** empty log message ***
@
text
@#!/usr/bin/env python3
#
# A mobility class for CRWP (Constrained Random Waypoint) model on a graph.
# Copyright (c) 2011, Hiroyuki Ohsaki.
# All rights reserved.
#
# $Id: crwp.py,v 1.1 2018/05/27 09:02:15 ohsaki Exp ohsaki $
#

import random

from dtnsim.mobility.graph.randomwalk import RandomWalk

class CRWP(RandomWalk):
    def __init__(self, pause_func=None, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if pause_func is None:
            pause_func = lambda: 0.0  # no pause time by default
        self.pause_func = pause_func
        self.goal = None
        self.goal_edge = None
        self.goal_offset = None
        self.wait = False
        self.pick_goal()
        self.update_velocity()

    def update_velocity(self):
        """Update agent's velocity."""
        self.velocity = self.vel_func()

    def update_goal_cache(self):
        """Compute and store the goal coordinate for later use."""
        self.goal = self.get_coordinate(self.goal_edge, self.goal_offset)

    def select_route(self):
        """Select the link through which the agent should proceed to reach its
        destination (goal).  This code assumes that the agent is just on the
        vertex and the graph is plannar."""
        # NOTE: this code assumes that the current position of the agent is is V
        u, v = self.current_edge
        pv = self.vertex_coordinate(v)
        next_ = u  # for fail safe
        min_angle = None
        # find the vertex W whose angle is closest to the goal
        for w in self.path.graph.neighbors(v):
            # never goes back to the coming direction
            if w == u:
                continue
            pw = self.vertex_coordinate(w)
            angle = self.angle_between_vectors(self.goal - pv, pw - pv)
            if min_angle is None or angle < min_angle:
                min_angle = angle
                next_ = w
        self.move_to_point([v, next_], 0)

    def reverse_current_if_necessary(self):
        """Reverse the current direction if the opposite is closer to the goal."""
        u, v = self.current_edge
        goal = self.goal - self.current
        via_v = self.vertex_coordinate(v) - self.current
        via_u = self.vertex_coordinate(u) - self.current
        if self.angle_between_vectors(
                goal, via_u) < self.angle_between_vectors(goal, via_v):
            length = self.edge_length(self.current_edge)
            self.current_edge = [v, u]
            self.current_offset = length - self.current_offset

    def pick_goal(self):
        """Randomly choose the location to go."""
        edge, offset = self.random_point()
        self.goal_edge = edge
        self.goal_offset = offset
        self.update_goal_cache()
        self.reverse_current_if_necessary()

    def move(self, delta):
        """Move the agent for the duration of DELTA."""
        # sleep until wait timer expires
        self.wait = max(self.wait - delta, 0)
        if self.wait > 0:
            return

        # advance the agent by SPEED * DELTA
        step = self.velocity * delta
        self.current_offset += step
        self.update_current_cache()

        l = self.edge_length(self.current_edge)
        # if close enough to the goal, randomly choose the next goal
        if abs(self.goal - self.current) < step:
            self.wait = self.pause_func()
            self.pick_goal()
            self.update_velocity()
        elif abs(self.current_offset - l) < step or self.current_offset > l:
            self.select_route()
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
# $Id: CRWP.pm,v 1.16 2015/12/11 08:14:40 ohsaki Exp $
a12 2
from tbdump import die, warn

a14 2

    # create and initialize the object
d18 5
a22 1
            pause_func = lambda: 0.0
a26 1
    # update the agent's velocity
d28 1
a30 1
    # compute and store the goal coordinate for later use
d32 1
d36 4
a39 2
        # NOTE: this code assumes that the current position is V
        # find the vertex whose angle is closest to that of the goal
d42 1
a42 1
        next = u  # for fail safe
d44 2
a45 1
        for w in (self.path.graph.neighbors(v)):
d53 2
a54 2
                next = w
        self.move_to_point([v, next], 0)
a55 1
    # reverse the current direction if the opposite is closer to the goal
d57 1
a67 1
    # randomly choose the location to go
d69 1
a75 1
    # move the agent for the duration of DELTA
d77 1
@
