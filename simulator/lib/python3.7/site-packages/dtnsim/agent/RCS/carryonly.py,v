head	1.6;
access;
symbols;
locks; strict;
comment	@# @;


1.6
date	2018.11.13.06.36.24;	author ohsaki;	state Exp;
branches;
next	1.5;

1.5
date	2018.11.13.06.34.27;	author ohsaki;	state Exp;
branches;
next	1.4;

1.4
date	2018.10.15.12.26.45;	author ohsaki;	state Exp;
branches;
next	1.3;

1.3
date	2018.10.15.11.58.55;	author ohsaki;	state Exp;
branches;
next	1.2;

1.2
date	2018.05.27.08.31.48;	author ohsaki;	state Exp;
branches;
next	1.1;

1.1
date	2018.05.26.20.02.57;	author ohsaki;	state Exp;
branches;
next	;


desc
@@


1.6
log
@*** empty log message ***
@
text
@#!/usr/bin/env python3
#
# Agent class for single-copy and carry-only routing.
# Copyright (c) 2011-2018, Hiroyuki Ohsaki.
# All rights reserved.
#
# Id: CarryOnly.pm,v 1.11 2015/12/11 08:14:04 ohsaki Exp $
#

import math

from perl import die, warn, getopts
import tbdump

MAX_RANGE = 50

class CarryOnly():
    def __init__(self,
                 id_=None,
                 scheduler=None,
                 mobility=None,
                 monitor=None,
                 range_=50):
        if id_ is None:
            id_ = len(scheduler.agents) + 1
        if not scheduler:
            die("Scheduler class must be specified.")
        if not mobility:
            die("Mobility class must be specified.")
        if not monitor:
            die("Monitor class must be specified.")
        if range_ > MAX_RANGE:
            die(f"range cannot exceed MAX_RANGE ({MAX_RANGE})")
        self.id_ = id_
        self.scheduler = scheduler
        self.mobility = mobility
        self.monitor = monitor
        self.range_ = range_

        self.last_neighbors = []
        self.received = {}
        self.receive_queue = {}
        self.delivered = {}
        self.tx_count = 0
        self.rx_count = 0
        self.dup_count = 0

        self.scheduler.add_agent(self)

    def __repr__(self):
        name = self.__class__.__name__
        return f'{name}(id_={self.id_!r}, mobility={self.mobility!r}, range_={self.range_!r}'

    def msg_src(self, msg):
        src = msg.split('-')[0]
        return int(src)

    def msg_dst(self, msg):
        dst = msg.split('-')[1]
        return int(dst)

    def msg_id(self, msg):
        id_ = msg.split('-')[2]
        return int(id_)

    def zone(self, x=None, y=None):
        """Return the zone (I, J) corresponding the geometry (X, Y)."""
        if x is None:
            x = self.mobility.current[0]
        if y is None:
            y = self.mobility.current[1]
        i = max(0, int(x / MAX_RANGE))
        j = max(0, int(y / MAX_RANGE))
        return i, j

    def cache_zone(self):
        """Record the zone of the current agent in the global zone cache."""
        i, j = self.zone()
        cache = self.scheduler.zone_cache
        cache.setdefault(j, {})
        cache[j].setdefault(i, [])
        self.scheduler.zone_cache[j][i].append(self)

    def neighbors(self):
        """Return neighbor agents within the communication range."""
        cache = self.scheduler.zone_cache
        if not cache:
            die("update_zone() must have been called for zone caching.")

        p = self.mobility.current
        i, j = self.zone()
        neighbors = []
        # check nine zones including/surrounding the current one
        for dj in [-1, 0, 1]:
            if j + dj < 0:
                continue
            for di in [-1, 0, 1]:
                if i + di < 0:
                    continue
                if not cache.get(j + dj, None):
                    continue
                if not cache[j + dj].get(i + di, None):
                    continue
                for agent in self.scheduler.zone_cache[j + dj][i + di]:
                    if agent == self:
                        continue
                    q = agent.mobility.current
                    if abs(p[0] - q[0]) > self.range_:
                        continue
                    if abs(p[1] - q[1]) > self.range_:
                        continue
                    if math.sqrt((p[0] - q[0])**2 +
                                 (p[1] - q[1])**2) > self.range_:
                        continue
                    neighbors.append(agent)
        return neighbors

    def encounters(self):
        """Return encoutered agents (i.e., newly visible agents)."""
        neighbors = self.neighbors()
        encounters = {agent.id_: agent for agent in neighbors}
        for agent in self.last_neighbors:
            try:
                del encounters[agent.id_]
            except KeyError:
                pass
        self.last_neighbors = neighbors
        return list(encounters.values())

    def sendmsg(self, agent, msg):
        """Send a message MSG to the agent AGENT."""
        agent.recvmsg(self, msg)
        self.tx_count += 1
        self.monitor.display_forward(self, agent, msg)
        self.monitor.change_agent_status(self)

    def recvmsg(self, agent, msg):
        """Receive a message MSG from the agent AGENT.  Note that the received
        message is temporally stored in the reception queue."""
        self.receive_queue.setdefault(msg, 0)
        self.receive_queue[msg] += 1
        self.rx_count += 1
        if self.received.get(msg, None):
            self.dup_count += 1
        self.monitor.change_agent_status(self)

    def messages(self):
        """Return all received messages."""
        return [msg for msg in self.received if self.received[msg] > 0]

    def pending_messages(self):
        """Return all messages need to be delivered."""
        return [
            msg for msg in self.messages() if self.msg_dst(msg) != self.id_
            and not self.delivered.get(msg, None)
        ]

    def accepted_messages(self):
        """Return successfully-received messages by the agent."""
        return [
            msg for msg in self.messages() if self.msg_dst(msg) == self.id_
        ]

    def forward(self):
        """Try to forward carrying messages to all encountered agents."""
        encounters = self.encounters()
        for agent in encounters:
            for msg in self.pending_messages():
                # forward carrying messages only to the destination
                dst = self.msg_dst(msg)
                if agent.id_ != dst:
                    continue
                self.sendmsg(agent, msg)
                del self.received[msg]
                self.delivered[msg] += 1

    def advance(self):
        """Advance the simulation for a delta time."""
        self.mobility.move(self.scheduler.delta)
        self.monitor.move_agent(self)
        self.forward()

    def flush(self):
        """Merge all newly-received messages with existing ones."""
        # NOTE: expand list to avoid run-time error
        for msg in list(self.receive_queue.keys()):
            self.received.setdefault(msg, 0)
            self.received[msg] += self.receive_queue[msg]
            del self.receive_queue[msg]
@


1.5
log
@*** empty log message ***
@
text
@d174 1
a174 1
                self.received[msg] -= 1
@


1.4
log
@*** empty log message ***
@
text
@d51 2
a52 1
        return f'CarryOnly {self.id_} @@ {self.mobility}'
d174 1
a174 1
                self.received[msg] += 1
@


1.3
log
@*** empty log message ***
@
text
@d107 1
a107 1
                    if abs(p[0] - q[0]) > self.range:
d109 1
a109 1
                    if abs(p[1] - q[1]) > self.range:
d112 1
a112 1
                                 (p[1] - q[1])**2) > self.range:
d170 1
a170 1
                if agent.id != dst:
@


1.2
log
@*** empty log message ***
@
text
@d4 1
a4 1
# Copyright (c) 2011-2015, Hiroyuki Ohsaki.
d12 2
a13 1
from tbdump import die, warn
a16 1

a17 1
    # create and initialize the object
d19 1
a19 1
                 id=None,
d23 3
a25 3
                 range=50):
        if id is None:
            id = len(scheduler.agents) + 1
d32 1
a32 1
        if range > MAX_RANGE:
d34 1
a34 1
        self.id = id
d38 1
a38 1
        self.range = range
d51 1
a51 1
        return f'CarryOnly {self.id} @@ {self.mobility}'
d54 2
a55 1
        return msg.split('-')[0]
d58 2
a59 1
        return msg.split('-')[1]
d62 2
a63 1
        return msg.split('-')[2]
a64 1
    # return the zone corresponding the geometry @@POS
d66 1
d76 1
a82 1
    # find neighbor nodes within the communication range
d84 1
d92 1
a92 1
        # check nine zones surrounding the current one
a114 1

a116 1
    # find encouter nodes (i.e., newly visible nodes)
d118 1
d120 1
a120 1
        encounters = {agent.id: agent for agent in neighbors}
d123 1
a123 1
                del encounters[agent.id]
a128 1
    # send a message to the specified agent
d130 1
a135 1
    # receive a message from the specified agent
d137 2
a138 1
        # received message is temporally stored in the reception queue
d147 1
a149 1
    # return all messages need to be delivered
d151 1
d153 1
a153 1
            msg for msg in self.messages() if self.msg_dst(msg) != self.id
d158 4
a161 1
        return [msg for msg in self.messages() if self.msg_dst(msg) == self.id]
d164 1
a175 1
    # advance the simulation for a delta time
d177 1
a181 1
    # merge received messages in the queue into the list
d183 1
@


1.1
log
@Initial revision
@
text
@d16 1
d19 10
a28 1
    def __init__( self,id=None,scheduler=None,mobility=None,monitor=None,range=50):
a30 2
        if not scheduler:
            die("Scheduler class must be specified.")
d33 1
a33 5
    
        nagents = len(scheduler.agents)
        if id is None:
            self.id = nagents + 1
        if range > MAX_RANGE :
d35 4
d40 9
a48 9
    
        self.last_neighbors= [] 
        self.received=      {}
        self.receive_queue= {} 
        self.delivered=     {} 
        self.tx_count=0
        self.rx_count=0
        self.dup_count=0
    
d50 5
a54 2
    
    def msg_src     ( self, msg ):
d56 2
a57 2
    
    def msg_dst     ( self, msg ):
d60 1
a60 1
    def msg_id     ( self, msg ):
d62 1
a62 1
    
d64 1
a64 1
    def zone     ( self, x=None, y=None ):
d69 6
a74 6
        i = max( 0, int( x / MAX_RANGE ) )
        j = max( 0, int( y / MAX_RANGE ) )
        return  i, j 
    
    def cache_zone     (self):
        i, j  = self.zone()
d77 1
a77 1
        cache.setdefault[j](i, [])
d79 1
a79 1
    
d81 5
a85 4
    def neighbors     (self):
        if not self.scheduler.zone_cache:
            die("update_zone() must have been called for creating zone database.")
    
d87 1
a87 2
        i, j  = self.zone()
        range = self.range()
d90 2
a91 2
        for dj in [-1, 0, 1 ]:
            if j + dj < 0 :
d93 6
a98 2
            for di in [ -1, 0, 1 ]:
                if i + di < 0 :
d100 2
a101 2
                for agent in self.scheduler.zone_cache[ j + dj ][ i + di ]:
                    if agent == self :
d104 1
a104 1
                    if abs( p[0] - q[0] ) > range:
d106 1
a106 1
                    if abs( p[1] - q[1] ) > range:
d108 2
a109 1
                    if math.sqrt( (p[0]-q[0])**2 + (p[1]-q[1])**2 ) > range :
d111 2
a112 2
                    neighbors.append( agent)
    
d114 1
a114 1
    
d116 3
a118 3
    def encounters     (self):
        neighbors = self.neighbors
        encounters = { agent.id : agent for agent in neighbors }
d120 4
a123 1
            del encounters[ agent.id ]
d125 2
a126 3
        return list( encounters.values() )
    
    
d128 2
a129 2
    def sendmsg     ( self, agent, msg ):
        agent.recvmsg( self, msg )
d131 1
a131 1
        self.monitor.display_forward( self, agent, msg )
d133 1
a133 1
    
d135 1
a135 1
    def recvmsg     ( self, agent, msg ):
d137 1
d140 1
a140 1
        if self.received[msg] :
d143 4
a146 4
    
    def messages     (self):
        return [ msg for msg in self.received if self.received[msg] > 0 ]
    
d148 10
a157 7
    def pending_messages     (self):
        return [ msg for msg in self.messages() if self.msg_dst(msg) != self.id and not self.delivered.get(msg, None)]
    
    def accepted_messages     (self):
        return [msg for msg in self.messages() if self.msg_dst(msg) == self.id ]
    
    def forward     (self):
d160 1
a160 1
            for msg in self.pending_messages() :
d163 1
a163 1
                if agent.id() != dst:
d165 1
a165 1
                self.sendmsg( agent, msg )
d168 1
a168 1
    
d170 2
a171 2
    def advance     (self):
        self.mobility.move( self.scheduler.delta )
d174 1
a174 1
    
d176 4
a179 2
    def flush     (self):
        for msg in self.receive_queue:
@
